# Entendendo a Inje√ß√£o de SQL (SQL Injection)

Este `README` √© um guia de estudo completo sobre uma das vulnerabilidades de seguran√ßa mais comuns e destrutivas em aplica√ß√µes web: a **Inje√ß√£o de SQL (SQLi)**. O objetivo aqui √© educacional, para que desenvolvedores e estudantes de seguran√ßa entendam a amea√ßa para poderem criar sistemas mais seguros.

## O que √© SQL Injection? üïµÔ∏è

Imagine que voc√™ vai a uma reparti√ß√£o p√∫blica e precisa preencher um formul√°rio para pedir um documento. O formul√°rio tem um campo: "Seu Nome". Voc√™ escreve seu nome, e o funcion√°rio pega essa informa√ß√£o, vai at√© um arquivo e busca sua pasta.

Agora, imagine que, em vez de escrever apenas seu nome, voc√™ escreve: *"Meu nome **E** traga tamb√©m a pasta de todas as outras pessoas"*. Se o funcion√°rio fosse um rob√¥ ing√™nuo que segue as instru√ß√µes literalmente, ele faria exatamente isso, comprometendo a privacidade de todos.

**SQL Injection √© exatamente isso.** √â uma vulnerabilidade que permite a um invasor "injetar" comandos SQL maliciosos dentro de uma consulta que a aplica√ß√£o j√° ia fazer ao banco de dados. Ao manipular a consulta original, o atacante pode for√ßar a aplica√ß√£o a entregar informa√ß√µes que n√£o deveria.

-----

## Por que √© t√£o Perigoso? (O Impacto) üí•

Uma explora√ß√£o bem-sucedida de SQLi pode ser catastr√≥fica. O invasor pode:

  * **Roubar dados sens√≠veis:** Acessar informa√ß√µes de todos os usu√°rios, senhas, n√∫meros de cart√£o de cr√©dito, dados pessoais, etc.
  * **Contornar autentica√ß√£o:** Fazer login como qualquer usu√°rio, incluindo administradores, sem precisar de senha.
  * **Alterar ou destruir dados:** Modificar saldos, apagar registros, ou deletar tabelas inteiras (`DROP TABLE`).
  * **Tomar controle do servidor:** Em algumas configura√ß√µes, √© poss√≠vel executar comandos no sistema operacional do servidor de banco de dados, comprometendo toda a infraestrutura.

-----

## Como Funciona na Pr√°tica?

A causa raiz do SQLi √© a **concatena√ß√£o de strings para montar consultas SQL**, usando dados que v√™m diretamente do usu√°rio sem o devido tratamento.

### O Cen√°rio Vulner√°vel

Veja um exemplo simples de c√≥digo **vulner√°vel** em PHP que busca um usu√°rio no banco de dados para fazer login:

```php
// CONEX√ÉO COM O BANCO DE DADOS (omitida por simplicidade)

// Pega os dados vindos de um formul√°rio de login
$username = $_POST['username']; // Ex: 'admin'
$password = $_POST['password']; // Ex: 'senha123'

// CRIA A CONSULTA SQL CONCATENANDO AS STRINGS - AQUI MORA O PERIGO!
$sql = "SELECT id FROM users WHERE username = '$username' AND password = '$password'";

// Executa a consulta...
$result = $conn->query($sql);

if ($result->num_rows > 0) {
    // Login bem-sucedido!
} else {
    // Falha no login.
}
```

### O Ataque

Um usu√°rio normal preencheria o campo `username` com `admin`. A consulta ficaria:
`SELECT id FROM users WHERE username = 'admin' AND password = '...';`

Agora, um invasor insere o seguinte "payload" no campo `username`:
` ' OR '1'='1' --  `

E pode deixar a senha em branco. Veja o que acontece com a string `$sql` no c√≥digo:

```sql
SELECT id FROM users WHERE username = '' OR '1'='1' -- ' AND password = ''
```

Vamos analisar a consulta manipulada:

  * `username = ''`: A primeira parte da condi√ß√£o √© falsa.
  * `OR '1'='1'`: MAS, o operador `OR` faz com que a cl√°usula `WHERE` inteira seja verdadeira se qualquer um dos lados for verdadeiro. Como `'1'='1'` √© **sempre verdade**, a condi√ß√£o √© satisfeita.
  * ` --  `: Isso √© um coment√°rio em SQL. Todo o resto da linha √© ignorado pelo banco de dados. A verifica√ß√£o da senha (`AND password = ...`) nunca acontece\!

**Resultado:** A consulta retorna o primeiro usu√°rio da tabela (que muitas vezes √© o administrador) e o sistema concede o acesso. O login foi contornado com sucesso.

-----

## Principais Tipos de SQL Injection

Existem v√°rias formas de explorar essa falha. As principais s√£o:

### 1\. In-band SQLi (Em Banda)

√â o tipo mais comum. O invasor usa o mesmo canal de comunica√ß√£o para lan√ßar o ataque e obter os resultados diretamente na p√°gina.

  * **Baseado em Erro:** For√ßa o banco a produzir uma mensagem de erro que revela informa√ß√µes sobre a estrutura do banco.
  * **Baseado em UNION:** Usa o operador `UNION` para combinar o resultado de uma consulta leg√≠tima com os dados de tabelas que o invasor quer acessar.

### 2\. Blind SQLi (Inje√ß√£o Cega)

Ocorre quando a aplica√ß√£o n√£o mostra os dados nem erros na tela. O ataque √© mais lento e funciona como um jogo de "quente ou frio".

  * **Booleano:** O invasor faz uma pergunta de "sim ou n√£o" e observa se a p√°gina muda. Ex: *"O primeiro caractere do nome do banco de dados √© 'a'?"*. Se a p√°gina carregar normalmente, a resposta √© sim. Se der erro, √© n√£o.
  * **Baseado em Tempo:** O invasor faz o banco de dados esperar por um tempo espec√≠fico se uma condi√ß√£o for verdadeira. Ex: *"Se o primeiro caractere da senha do admin for 's', espere 5 segundos"*. Se a p√°gina demorar 5 segundos a mais para carregar, a condi√ß√£o √© verdadeira.

### 3\. Out-of-band SQLi (Fora de Banda)

√â mais rara e complexa. √â usada quando o servidor n√£o retorna nenhuma resposta diferente. O invasor for√ßa o banco de dados a fazer uma conex√£o de rede para um servidor externo controlado por ele, enviando os dados por esse outro canal (ex: uma requisi√ß√£o DNS ou HTTP).

-----

## üõ°Ô∏è Como se Proteger: A Preven√ß√£o

Felizmente, proteger-se contra SQL Injection √© relativamente simples se voc√™ seguir as boas pr√°ticas desde o in√≠cio.

### A Regra de Ouro: Consultas Parametrizadas (Prepared Statements)

Essa √© a forma **mais eficaz** de preven√ß√£o. Em vez de concatenar strings, voc√™ cria um "molde" da consulta com marcadores (`?` ou `:nome`) e envia os dados do usu√°rio separadamente. O banco de dados trata os dados de entrada sempre como **dados**, nunca como parte do **c√≥digo** SQL.

Veja o mesmo c√≥digo de login, agora **seguro**, usando Prepared Statements em PHP:

```php
// Pega os dados vindos de um formul√°rio de login
$username = $_POST['username'];
$password = $_POST['password'];

// 1. PREPARA O "MOLDE" DA CONSULTA com marcadores (?)
$stmt = $conn->prepare("SELECT id FROM users WHERE username = ? AND password = ?");

// 2. VINCULA os dados do usu√°rio aos marcadores. O banco de dados garante que eles ser√£o tratados apenas como texto.
$stmt->bind_param("ss", $username, $password); // "ss" significa que ambas as vari√°veis s√£o strings

// 3. EXECUTA a consulta de forma segura
$stmt->execute();

$result = $stmt->get_result();

if ($result->num_rows > 0) {
    // Login bem-sucedido!
} else {
    // Falha no login.
}
```

Agora, se o invasor inserir ` ' OR '1'='1' --  ` no campo de usu√°rio, o banco de dados ir√° procurar literalmente por um usu√°rio com o nome bizarro ` ' OR '1'='1' --  ` e, como n√£o encontrar√°, o login falhar√°. O ataque √© neutralizado.

### Outras Camadas de Defesa

1.  **Valida√ß√£o de Entrada (Input Validation):** Sempre valide os dados de entrada. Se voc√™ espera um n√∫mero, verifique se √© um n√∫mero. Se espera uma data, verifique o formato.
2.  **Sanitiza√ß√£o de Entrada (Input Sanitization):** "Limpe" os dados, escapando caracteres especiais que t√™m significado em SQL (como `'`). Fun√ß√µes de Prepared Statements j√° fazem isso automaticamente.
3.  **Princ√≠pio do Menor Privil√©gio:** Crie um usu√°rio no banco de dados para a sua aplica√ß√£o que tenha apenas as permiss√µes estritamente necess√°rias. Ele n√£o precisa ter permiss√£o para dar `DROP TABLE`, por exemplo.
