## Guia Completo: Explorando uma Vulnerabilidade de Inje√ß√£o de SQL

### O Motivo da Vulnerabilidade: Por que isso funciona?

A vulnerabilidade de Inje√ß√£o de SQL (SQLi) descrita neste guia acontece por um motivo fundamental: **a aplica√ß√£o n√£o valida nem "sanitiza" os dados fornecidos pelo usu√°rio antes de us√°-los para construir uma consulta ao banco de dados.**

Em vez de tratar a entrada do usu√°rio (o termo de busca) como um simples texto, o sistema a insere diretamente na string da query SQL. Isso permite que um atacante "injete" seus pr√≥prios comandos SQL.

Ao usar caracteres especiais como aspas duplas (`"`) e coment√°rios (`--`), o atacante consegue "quebrar" a query original, enganando o banco de dados para que ele execute comandos n√£o previstos pelos desenvolvedores, como revelar dados de outras tabelas (`UNION`) ou ignorar filtros (`--`).

---

### Parte 1: Revelando Rotas e Informa√ß√µes

Esta aplica√ß√£o tem `posts` (postagens) e `users` (usu√°rios). Tente criar, exibir e editar algumas postagens usando a aplica√ß√£o.

Agora, visite um caminho na aplica√ß√£o que n√£o existe de verdade, como `/asdf`, navegando diretamente para essa URL inv√°lida. Como esta aplica√ß√£o est√° configurada para rodar em modo de desenvolvimento (em vez de depender corretamente do ambiente de `production` [produ√ß√£o]), voc√™ provocar√° um erro de roteamento que revela informa√ß√µes √∫teis e sens√≠veis.

Voc√™ consegue ver algum caminho revelado que possa apontar para funcionalidades adicionais do backend que valem a pena explorar?

---

### Parte 2: Testando a Inje√ß√£o de SQL B√°sica

A √∫ltima rota listada √© um `search_path` (caminho de busca) que nos permite procurar por postagens com conte√∫do correspondente. Embora n√£o esteja documentada, ela tamb√©m n√£o est√° protegida e pode ser acessada por qualquer pessoa.

Este endpoint realiza uma consulta ao banco de dados usando uma query SQL como a seguinte:
$$\text{select title, content from posts where content like "\%yoursearchterm\%";}$$

Tente pesquisar por um caractere de aspas duplas (`"`) visitando a URL `/search/"`. Isso causar√° um erro, pois a query se tornar√° inv√°lida:
$$\text{select title, content from posts where content like "\%"\%";}$$

Agora, tente uma varia√ß√£o diferente, usando caracteres de coment√°rio:
$$\text{"--}$$

Note como, embora esta query tamb√©m inclua aspas duplas, os resultados s√£o diferentes. Neste caso, retornamos **todas** as postagens existentes. Isso acontece porque a query no backend se torna:
$$\text{SELECT title, content FROM posts WHERE content LIKE "\%"--\%";}$$

Como `--` inicia um coment√°rio em SQL, o resto do c√≥digo original (`%";`) √© ignorado. A consulta efetivamente executada √© `...WHERE content LIKE "%"`, que retorna tudo.

---

### Parte 3: Extraindo Dados de Outras Tabelas com `UNION`

Agora que controlamos a query, podemos extrair dados de outras tabelas, como a de usu√°rios (`users`). Para isso, usamos uma instru√ß√£o **`UNION`**.

Primeiro, precisamos descobrir o n√∫mero de colunas que a query original retorna. Tentaremos com uma coluna (`email`):
`/search/" union select email from users where email like "`

Isso resultar√° no erro: **"SELECTs √† esquerda e √† direita do UNION n√£o t√™m o mesmo n√∫mero de colunas de resultado"**. O erro nos diz que precisamos de mais colunas. Como a query original busca por `title` e `content`, sabemos que s√£o duas colunas.

Vamos corrigir nossa tentativa, pedindo duas colunas (usando `email` duas vezes):
`/search/" union select email, email from users where email like "`

Isso deve revelar os e-mails dos usu√°rios existentes no banco de dados!

---

### Parte 4: Retornando Dados Sens√≠veis

Agora podemos incluir quaisquer outros nomes de campo na nossa query `UNION`. Se tivermos a sorte de adivinhar ou descobrir um campo como `encrypted_password`, poder√≠amos tentar a seguinte query para extrair e-mails e senhas:
`" union select email, encrypted_password from users where email like "`

Fa√ßa o teste; ela deve retornar os e-mails dos dois usu√°rios juntamente com suas senhas (que, neste exemplo, n√£o est√£o realmente criptografadas). üîê

A partir daqui, usando os caracteres de coment√°rio (`--`), voc√™ pode ignorar completamente a parte final da query original para construir instru√ß√µes ainda mais complexas e personalizadas.