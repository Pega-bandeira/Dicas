## Vulnerabilidade de Endpoints Expostos (Neglected Endpoints)

### Introdu√ß√£o √† Falha de Autoriza√ß√£o

A explora√ß√£o de uma falha de **Autoriza√ß√£o a N√≠vel de Fun√ß√£o** (Function Level Authorization) ocorre quando um invasor consegue executar chamadas de API leg√≠timas para um endpoint que ele n√£o deveria ter permiss√£o para acessar.

Como os endpoints de uma API geralmente seguem uma estrutura previs√≠vel, um invasor pode deduzir o padr√£o das rotas para tentar acessar endpoints reservados para outros usu√°rios ou perfis (roles).

Nesta li√ß√£o, usamos uma API de um banco fict√≠cio para demonstrar como proteger endpoints contra acessos n√£o autorizados. Veremos como um cliente mal-intencionado, logado como um usu√°rio comum, pode analisar a estrutura da API para encontrar e explorar endpoints desprotegidos.

O objetivo √© aprender a mitigar essa vulnerabilidade e garantir que os endpoints estejam acess√≠veis apenas para os clientes autorizados.

-----

## Etapa 1: Descoberta de Endpoints Ocultos

### Padr√µes de Rotas da API

Billy, um cliente do banco, est√° aprendendo sobre vulnerabilidades de seguran√ßa e decide investigar a API do seu banco. Ele sabe que as rotas de uma API costumam seguir um padr√£o. Por exemplo, um endpoint comum nesta API √©:

`GET /api/account/{accountId}`

A rota √© formada por `/api/` seguido pela entidade, neste caso, `account`. Com base nisso, um invasor pode deduzir outros endpoints relacionados, como:

  * `GET /api/account/{accountId}`: para obter uma conta espec√≠fica.
  * **`GET /api/accounts`**: para obter todas as contas.
  * `POST /api/account`: para criar uma nova conta.
  * `PUT /api/account/{accountId}`: para modificar uma conta existente.

Billy tenta fazer uma requisi√ß√£o para o segundo endpoint (`/api/accounts`) sem um token de autentica√ß√£o:

```bash
curl -IH 'Origin: https://securitylabs.veracode.com' https://60b0f6d1.vsl.dev/api/accounts
```

Ele recebe uma resposta **`HTTP/2 401 Unauthorized`** (N√£o Autorizado), o que √© esperado. No entanto, se ele recebesse qualquer outra resposta, isso poderia indicar que o endpoint existe e est√° desprotegido.

### Automatizando a Descoberta

Para encontrar endpoints ocultos de forma eficiente, Billy usa um script que testa v√°rias palavras de um dicion√°rio (`words.txt`) como poss√≠veis nomes de rotas. O script tenta acessar `/api/$palavra/accounts` e verifica se a resposta √© diferente de `401`.

**Script de Descoberta:**

```bash
cat words.txt | tr -d '\r' | while read i; do
  printf "%s - response... " "trying /api/$i/accounts"
  # Verifica se a resposta N√ÉO √© 401
  curl -IsH "Origin: https://securitylabs.veracode.com" https://60b0f6d1.vsl.dev/api/$i/accounts | grep 'HTTP/2 401'
  if [[ $? -ne 0 ]]; then
    echo ' no 401'
    echo Hidden route found: /api/$i/accounts;
    break;
  fi;
done
```

Ap√≥s alguns segundos, o script encontra uma rota que n√£o retorna o erro `401`:

```
...
trying /api/auditorially/accounts - response... HTTP/2 401
trying /api/auditorium/accounts - response... HTTP/2 401
trying /api/auditors/accounts - response...  no 401
Hidden route found: /api/auditors/accounts
```

A rota oculta **/api/auditors/accounts** foi encontrada. Agora, √© preciso verificar se ela est√° realmente desprotegida.

-----

## Etapa 2: Explora√ß√£o da Vulnerabilidade

Para confirmar a falha, Billy acessa a rota descoberta, novamente sem qualquer autentica√ß√£o:

```bash
curl -H 'Origin: https://securitylabs.veracode.com' https://60b0f6d1.vsl.dev/api/auditors/accounts | jq
```

O resultado √© um sucesso para o invasor: ele obt√©m uma lista de todas as contas do banco, com dados sens√≠veis como ID, usu√°rio, CPF (SSN) e saldo.

```json
[
  {
    "id": "CA-1000-20988",
    "user": "Emily",
    "ssn": "456-78-901",
    "balance": 145700
  },
  {
    "id": "CA-1000-20987",
    "user": "Billy",
    "ssn": "123-45-6789",
    "balance": 5440
  },
  ...
]
```

Isso aconteceu porque um desenvolvedor, com pressa para corrigir um bug, adicionou o endpoint `/api/auditors/accounts` a uma lista de exce√ß√µes de autentica√ß√£o e esqueceu de remover depois.

-----

## Etapa 3: Corrigindo a Falha de Autentica√ß√£o e Autoriza√ß√£o

### Corre√ß√£o 1: Exigir Autentica√ß√£o

A primeira corre√ß√£o √© remover o endpoint da lista de rotas n√£o protegidas.

**Arquivo:** `authentication.middleware.js`

```javascript
const nonProtectedRoutes = [
  '/',
  '/api/login',
  '/api/auth',
  '/api/register',
  '/api/encrypt',
  // '/api/auditors/accounts', // Linha removida/comentada
];
```

Ap√≥s remover a linha e reiniciar a API, uma nova tentativa de acesso sem token resulta no erro esperado: **`401 Unauthorized`**. O endpoint agora exige autentica√ß√£o.

### Corre√ß√£o 2: Implementar Autoriza√ß√£o por Perfil (Role)

Embora o endpoint agora exija um login, Billy (um `ACCOUNT_HOLDER` - correntista) ainda consegue acess√°-lo se usar seu pr√≥prio token. No entanto, essa rota deveria ser restrita apenas a usu√°rios com o perfil `AUDITOR`.

A solu√ß√£o √© aplicar um *middleware* de autoriza√ß√£o que verifique o perfil do usu√°rio.

**Arquivo:** `bankAccount.controller.js`

```javascript
// ... c√≥digo anterior
router.get(
  '/auditors/accounts',
  // A linha abaixo √© descomentada para ativar a verifica√ß√£o de perfil
  authorizeMiddleware([AUTHORITIES.AUDITOR]), // <- CORRE√á√ÉO
  getAll,
);
// ...
```

Este c√≥digo garante que apenas usu√°rios com o token contendo o escopo (`scope`) de `AUDITOR` possam acessar este endpoint.

-----

## Etapa 4: Teste Final e Valida√ß√£o

Com as duas corre√ß√µes aplicadas, realizamos os testes finais:

1.  **Acesso com o token de Billy (Correntista):**
    A tentativa de acesso agora retorna **`403 Forbidden`** (Proibido). Acesso negado com sucesso.

2.  **Acesso com o token de John (Auditor):**
    Obtemos um novo token para o usu√°rio `John`, que tem o perfil `AUDITOR`. Ao usar esse token, a requisi√ß√£o √© bem-sucedida e retorna os dados das contas.

Agora, o endpoint est√° protegido corretamente por **autentica√ß√£o** (requer login) e **autoriza√ß√£o** (requer o perfil correto). Bom trabalho\! üëç

-----

## Recomenda√ß√µes Finais de Seguran√ßa

  * **Negue por Padr√£o:** Aplique a regra de ouro da autoriza√ß√£o: negue todo o acesso por padr√£o e libere apenas para perfis espec√≠ficos.
  * **Testes Integrados:** Implemente testes automatizados para autentica√ß√£o e autoriza√ß√£o em todos os endpoints. Isso poderia ter evitado o erro do "desenvolvedor apressado".
  * **Invent√°rio de Endpoints:** Mantenha um invent√°rio de todos os endpoints da API e seus requisitos de acesso.
  * **Separe APIs Internas:** Se houver endpoints para uso interno, coloque-os em uma API separada e protegida.
  * **Rotas N√£o Previs√≠veis:** Para endpoints de uso tempor√°rio ou que cont√™m informa√ß√µes muito sens√≠veis, use rotas com hashes ou GUIDs para dificultar a descoberta por for√ßa bruta. Exemplo:
    `api/2759449F-FA32-4FB9-8A2F-33D92BC5F6A5/accounts`