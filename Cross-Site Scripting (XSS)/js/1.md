
---

# ğŸŒ **VocÃª consegue ver seu reflexo?** â€“ Cross-Site Scripting (XSS)

## ğŸ“Œ IntroduÃ§Ã£o

**Cross-site scripting (XSS)** Ã© um tipo de ataque onde um usuÃ¡rio mal-intencionado consegue **injetar cÃ³digo JavaScript malicioso** em uma pÃ¡gina que serÃ¡ visualizada por outro usuÃ¡rio.

Existem **duas formas principais** de XSS:

* **Refletido (nÃ£o persistente)** â†’ O atacante cria uma URL que, quando acessada, executa o cÃ³digo malicioso imediatamente.
* **Armazenado (persistente)** â†’ O conteÃºdo malicioso Ã© armazenado no servidor (ex.: arquivos ou campos salvos) e entregue a outros usuÃ¡rios.

Neste laboratÃ³rio, um aplicativo Node.js reflete conteÃºdo de entrada de volta ao usuÃ¡rio, permitindo **injetar e executar cÃ³digo JavaScript nÃ£o confiÃ¡vel.**

---

## ğŸ§ª Testando um XSS Refletido

### 1ï¸âƒ£ Teste inicial

Digite algum texto simples no campo de entrada para ver como o app se comporta.
Depois, insira o seguinte cÃ³digo:

```html
<script>alert(1)</script>
```

ğŸ“Œ **Resultado esperado:**
Um alerta deve aparecer com o nÃºmero `1`, provando que conseguimos executar cÃ³digo na pÃ¡gina.

---

### 2ï¸âƒ£ Testando com HTML

Tente inserir tags HTML, como:

```html
<h1>OlÃ¡!</h1>
```

Ou atÃ© mesmo cÃ³digo para alterar o fundo da pÃ¡gina:

```html
<body style="background:red"></body>
```

ğŸ”¹ Com esforÃ§o suficiente, seria possÃ­vel **modificar toda a pÃ¡gina**, fazendo-a parecer um **site falso (phishing).**

---

âš ï¸ **Importante:**
Como a execuÃ§Ã£o resulta de um **POST** e nÃ£o de parÃ¢metros na URL, **nÃ£o seria possÃ­vel apenas enviar um link para outro usuÃ¡rio**.
Para um ataque real, isso poderia ser combinado com **CSRF (Cross-Site Request Forgery)**.

---

## ğŸ”’ CabeÃ§alho X-XSS-Protection

No arquivo **app.js**, hÃ¡ uma linha que define o cabeÃ§alho **X-XSS-Protection: 0**, que **desativa proteÃ§Ãµes em navegadores antigos**.

```js
res.setHeader("X-XSS-Protection", "0");
```

### âœ… CorreÃ§Ã£o

â¡ï¸ **Remova essa linha**, salve o arquivo e reinicie o app com:

```
boot
```

Dependendo do navegador, vocÃª poderÃ¡ ver um aviso de conteÃºdo suspeito bloqueado.

---

## ğŸ›¡ï¸ Escapando a Entrada do UsuÃ¡rio

Mesmo com cabeÃ§alhos de proteÃ§Ã£o, **nunca devemos confiar no navegador do usuÃ¡rio para prevenir XSS.**

No arquivo **/views/index.pug**, temos:

```pug
h5!= term
```

ğŸ”¹ O `!=` insere o conteÃºdo **sem escapar caracteres**, permitindo a execuÃ§Ã£o de HTML/JS.

### âœ… CorreÃ§Ã£o

Troque por:

```pug
h5= term
```

Agora, se tentarmos inserir:

```html
<script>alert(1)</script>
>```

O resultado serÃ¡ exibido como **texto**, e nÃ£o como cÃ³digo executÃ¡vel:

```
&lt;script&gt;alert(1)&lt;/script&gt;
```

âœ… Assim, os caracteres `<` e `>` sÃ£o **escapados**, impedindo execuÃ§Ã£o de cÃ³digo.

---

## ğŸš€ PrÃ³ximos Passos

âœ… Vimos como **detectar e corrigir XSS refletido**.
ğŸ”¹ O prÃ³ximo passo Ã© estudar o **XSS persistente**, onde o conteÃºdo malicioso **fica armazenado no servidor** e Ã© entregue a outros usuÃ¡rios.

---

### ğŸ“– Resumo

âœ” **Falha:** Entrada do usuÃ¡rio refletida sem validaÃ§Ã£o.
âœ” **Teste:** `<script>alert(1)</script>` â†’ executa JavaScript no navegador.
âœ” **CorreÃ§Ã£o:**

* Remover cabeÃ§alho `X-XSS-Protection: 0`
* Escapar entrada no template (`h5= term` em vez de `h5!= term`)

---

âš¡ **Quer que eu crie um README.md completo**, incluindo:
âœ… **ExplicaÃ§Ã£o sobre XSS refletido e persistente**
âœ… **Exemplos inseguros e seguros (antes/depois)**
âœ… **Boas prÃ¡ticas para prevenÃ§Ã£o em Node.js, Java e C#?**

Posso gerar **um guia Ãºnico de prevenÃ§Ã£o de XSS + SQL Injection**, com exemplos prÃ¡ticos para vÃ¡rias linguagens.
ğŸ”¹ **Quer que eu faÃ§a isso?**
